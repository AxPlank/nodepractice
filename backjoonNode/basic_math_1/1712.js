/*
백준 1712: 손익분기점
https://www.acmicpc.net/problem/1712
*/

const fs = require('fs');

let [A, B, C] = fs.readFileSync("../inputt.txt").toString().trim().split(' ').map(Number);

if (B >= C) {
    console.log(-1);
} else {
    console.log(Math.floor(A/(C-B)) + 1);
}

/*
Math.ceil()을 사용했을 때 틀렸다고 나오는 이유에 대한 추측

Math.ceil()과 Math.floor()은 각각 임의의 실수에 올림 혹은 버림을 적용한 값을 리턴시키는 함수이다.
하지만 완벽히 그 값을 리턴하는 것은 아니다.
실제로 0 미만이면서 -1을 초과하는 임의의 실수에 대해 Math.ceil()을 적용하면, -0이 리턴되어 출력되고,
반대로 0 초과이면서 1 미만인 임의의 실수에 대해 Math.floor()를 적용하면 0이 리턴된다.

즉, 완벽히 올림/버림을 적용한 값을 리턴시키는 것이 아니라, 
올림/버림했을 때 반환되어야 할 정수의 근방에 있는 임의의 실수를 리턴하는 것이다.
세 수 a, b, c가 있을 때(a <= b <= c), 올림/버림을 적용한 값이 x라 한다면,
a에서 Math.ceil()을 이용해 올림을 적용하면, x는 b - x ≒ 0 && a ≒ b && a < x < b를 만족하고,
반대로 c에서 Math.floor()을 이용해 내림을 적용한다면, x는 x - b ≒ 0 && c ≒ b && b < x < c인 를 만족할 것이다.
실제로도 b - x와 x - b는 0이라고 무방할 정도로 차이가 적으며, 
그 정도는 toFixed()를 이용해 확인했을 때, 
toFiexed()를 이용해서 출력할수 있는 가장 깊은 자리까지 동일하게 나올 정도로 작았다.

이렇기 떄문에 당연히 적용된 값들을 비교했을 때, 
각각을 적용한 값들은 실제로 다르지만 서로 같다고 출력되는 것이며, 
동일한 이유로 백준에서도 틀렸다고 나오는 것으로 추측된다.
정리: 부동 소수점 문제임 ㅇㅇ
*/